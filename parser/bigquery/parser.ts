// generated by Textmapper; DO NOT EDIT

import * as common from './common';
import * as token from './token';
import * as lexer from './lexer';
import * as listener from './listener';
import * as ptables from './parser_tables';
import * as stream from './stream';

// ErrorHandler is called every time a parser is unable to process some part of the input.
// This handler can return false to abort the parser.
export type ErrorHandler = (err: SyntaxError) => boolean;

// StopOnFirstError is an error handler that forces the parser to stop on and return the first
// error.
export const StopOnFirstError : ErrorHandler = (err : SyntaxError) : boolean => false;

export type SyntaxError = {
  line: number;
  offset: number;
  endoffset: number;
};

export function ErrorMsg(err : SyntaxError) : string {
  return "syntax error at line " + err.line;
}

  const errSymbol = 367

// reduceAll simulates all pending reductions and returns true if the parser
// can consume the next token in the `stack+[state]` parsing stack. This
// function also returns the state of the parser after the reductions have been
// applied (but before symbol is shifted).
function reduceAll(stack: common.StackEntry[], state: number, symbol: number, endState: number) : [number, boolean] {
  if (symbol === ptables.noToken) {
    throw new Error("a valid next token is expected");
  }
  if (state < 0) {
    return [0, false];
  }

  let stack2: number[] = [state];
  let size = stack.length;

  while (state !== endState) {
    let action = ptables.tmAction[state];
    if (action > ptables.tmActionBase) {
      let pos = action + symbol;
      if (pos >= 0 && pos < ptables.tmTableLen && ptables.tmCheck[pos] === symbol) {
        action = ptables.tmTable[pos];
      } else {
        action = ptables.tmDefAct[state];
      }
    } else {
      action = ptables.tmDefAct[state];
    }

    if (action >= 0) {
      // Reduce.
      let rule = action;
      let ln = ptables.tmRuleLen[rule];
      let symbol = ptables.tmRuleSymbol[rule];

      if (ln > 0) {
        if (ln < stack2.length) {
          state = stack2[stack2.length - ln - 1];
          stack2 = stack2.slice(0, stack2.length - ln);
        } else {
          size -= ln - stack2.length;
          state = stack[size - 1].state;
          stack2 = [];
        }
      }
      state = gotoState(state, symbol);
      stack2.push(state);
    } else {
      return [state, action < -1];
    }
  }
  return [state, symbol === ptables.eoiToken];
}

function gotoState(state: number, symbol: number) : number {
  let numTokens = 368;
  if (symbol >= numTokens) {
    let pos = ptables.tmGoto[symbol - numTokens] + state;
    if (pos >= 0 && pos < ptables.tmTableLen && ptables.tmCheck[pos] === state) {
      return ptables.tmTable[pos];
    }
    return ptables.tmDefGoto[symbol-numTokens];
  }

  // Shifting a token.
  let action = ptables.tmAction[state];
  if (action === ptables.tmActionBase) {
    return -1;
  }
  let pos = action + symbol;
  if (pos >= 0 && pos < ptables.tmTableLen && ptables.tmCheck[pos] === symbol) {
    action = ptables.tmTable[pos];
  } else {
    action = ptables.tmDefAct[state];
  }
  if (action < -1) {
    return -2 - action;
  }
  return -1;
}

// Parser is a table-driven LALR parser for sql.
export class Parser {
  _eh: ErrorHandler;
  _listener: listener.Listener;
  _next: common.Symbol;
  _recovering: number;
  constructor(eh: ErrorHandler, listener: listener.Listener) {
    this._eh = eh;
    this._listener = listener;
    this._next = new common.Symbol(token.TokenType.UNAVAILABLE, 0, 0);
  }

  parseSqlStatement(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(0, 3484, stream);
  }

  parseScript(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(1, 3485, stream);
  }

  parseNextStatement(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(2, 3486, stream);
  }

  parseNextScriptStatement(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(3, 3487, stream);
  }

  parseNextStatementKind(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(4, 3488, stream);
  }

  parseExpression(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(5, 3489, stream);
  }

  parseType(stream: stream.TokenStream) : { err? : SyntaxError } {
    return this.doParse(6, 3490, stream);
  }

  private doParse(start: number, end: number, stream: stream.TokenStream) : {  err?: SyntaxError } {
    let state = start;
    let lastErr: SyntaxError = {
      line: 0,
      offset: 0,
      endoffset: 0
    };
    this._recovering = 0;

    let stack: common.StackEntry[] | null = [{sym: new common.Symbol(token.TokenType.UNAVAILABLE, 0, 0), state: state }];
    this._next = stream.next(stack, end);

    while (state !== end) {
      let action = ptables.tmAction[state];
      if (action > ptables.tmActionBase) {
        // Lookahead is needed.
        if (this._next.symbol === ptables.noToken) {
          this._next = stream.next(stack, end);
        }
        let pos = action + this._next.symbol;
        if (pos >= 0 && pos < ptables.tmTableLen && ptables.tmCheck[pos] === this._next.symbol) {
          action = ptables.tmTable[pos];
        } else {
          action = ptables.tmDefAct[state];
        }
      } else {
        action = ptables.tmDefAct[state];
      }
      if (action >= 0) {
        // Reduce.
        let rule = action;
        let ln = ptables.tmRuleLen[rule];


        let entry : common.StackEntry = { sym: new common.Symbol(ptables.tmRuleSymbol[rule], 0, 0), state: 0 };
        let rhs = stack.slice(stack.length - ln);
        while (ln > 0 && rhs[ln-1].sym.offset === rhs[ln-1].sym.endoffset) {
          ln--;
        }
        if (ln === 0) {
          if (this._next.symbol === ptables.noToken) {
            this._next = stream.next(stack, end);
          }
          entry.sym.offset = this._next.offset;
          entry.sym.endoffset = this._next.offset;
        } else {
          entry.sym.offset = rhs[0].sym.offset;
          entry.sym.endoffset = rhs[ln - 1].sym.endoffset;
        }
        this.applyRule(rule, entry, stack, stream);
        stack = stack.slice(0, stack.length - rhs.length);
        if (common.debugSyntax) {
          common.debugLog("reduced to", ptables.symbolName(entry.sym.symbol));
        }
        state = gotoState(stack[stack.length - 1].state, entry.sym.symbol);
        entry.state = state;
        stack.push(entry);

      } else if (action < -1) {
        // Shift.
        state = -2 - action;
          stack.push({
            sym:   this._next.copy(),
            state: state,
          });
          if (common.debugSyntax) {
            common.debugLog("lookahead shift:", ptables.symbolName(this._next.symbol), "(", stream.text(this._next), ")");
          }
          stream.flush(this._next);
          if (this._next.symbol !== ptables.eoiToken) {
            this._next.symbol = ptables.noToken;
          }
          if (this._recovering > 0) {
            this._recovering--;
          }
      }

      if (action === -1 || state === -1) {
        if (this._recovering === 0) {
          if (this._next.symbol === ptables.noToken) {
            this._next = stream.next(stack, end);
          }
          lastErr = {
            line:      stream.line(),
            offset:    this._next.offset,
            endoffset: this._next.endoffset
          };
          if (!this._eh(lastErr)) {
            stream.flush(this._next);
            return { err : lastErr };
          }
        }

        this._recovering = 4;
        stack = this.recoverFromError(stream, stack, end)
        if (stack === null || stack === undefined) {
          stream.flush(this._next)
          return { err : lastErr };
        }
        state = stack[stack.length - 1].state;
      }
    }


    return { };

  }

  private applyRule(rule: number, lhs: common.StackEntry, stack: common.StackEntry[], stream: stream.TokenStream) : void {
    switch (rule) {
      case 74: // query_statement : query
        this.reportRange(listener.NodeType.Query, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 128: // alter_statement : 'ALTER' table_or_table_function opt_if_exists maybe_dashed_path_expression syntax_problem alter_action_list
        this.reportRange(listener.NodeType.TableName, listener.NodeFlags.RetainText, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 129: // alter_statement : 'ALTER' table_or_table_function opt_if_exists maybe_dashed_path_expression alter_action_list
        this.reportRange(listener.NodeType.TableName, listener.NodeFlags.RetainText, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 164: // set_statement : 'SET' path_expression '=' expression
        this.reportRange(listener.NodeType.PathExpr, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 167: // set_statement : 'SET' '(' identifier_list ')' '=' expression
        this.reportRange(listener.NodeType.IDList, 0, stack.slice(stack.length - 4, stack.length - 3));
        break;
      case 175: // create_constant_statement : 'CREATE' opt_or_replace opt_create_scope 'CONSTANT' opt_if_not_exists path_expression '=' expression
        this.reportRange(listener.NodeType.ConstName, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 176: // create_database_statement : 'CREATE' 'DATABASE' path_expression opt_options_list
        this.reportRange(listener.NodeType.DatabaseName, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 185: // function_declaration : path_expression function_parameters
        this.reportRange(listener.NodeType.FuncName, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 190: // function_parameters_list : function_parameters_list ','
        this.reportRange(listener.NodeType.SyntaxProblem, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 191: // function_parameters : '(' function_parameters_list ')'
        this.reportRange(listener.NodeType.FuncParams, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 195: // create_procedure_statement : 'CREATE' opt_or_replace opt_create_scope 'PROCEDURE' opt_if_not_exists path_expression procedure_parameters opt_with_connection_clause opt_options_list unlabeled_begin_end_block_or_language_as_code
        this.reportRange(listener.NodeType.ProcedureName, 0, stack.slice(stack.length - 5, stack.length - 4));
        break;
      case 230: // as_sql_function_body_or_string : 'AS' sql_function_body
        this.reportRange(listener.NodeType.FuncBody, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 262: // create_external_table_statement : 'CREATE' opt_or_replace opt_create_scope 'EXTERNAL' 'TABLE' opt_if_not_exists maybe_dashed_path_expression opt_table_element_list opt_like_path_expression opt_default_collate_clause opt_external_table_with_clauses opt_options_list
        this.reportRange(listener.NodeType.ExternalTableName, listener.NodeFlags.RetainText, stack.slice(stack.length - 6, stack.length - 5));
        break;
      case 264: // create_index_statement : 'CREATE' opt_or_replace opt_unique opt_spanner_null_filtered opt_search 'INDEX' opt_if_not_exists path_expression 'ON' path_expression opt_as_alias opt_index_unnest_expression_list index_order_by opt_index_storing_list opt_options_list opt_spanner_index_interleave_clause
        this.reportRange(listener.NodeType.IndexName, 0, stack.slice(stack.length - 9, stack.length - 8));
        break;
      case 268: // create_table_statement : 'CREATE' opt_or_replace opt_create_scope 'TABLE' opt_if_not_exists maybe_dashed_path_expression opt_table_element_list opt_spanner_table_options opt_like_path_expression opt_clone_table opt_copy_table opt_default_collate_clause opt_partition_by_clause_no_hint opt_cluster_by_clause_no_hint opt_ttl_clause opt_options_list opt_as_query
        this.reportRange(listener.NodeType.TableName, listener.NodeFlags.RetainText, stack.slice(stack.length - 12, stack.length - 11));
        break;
      case 269: // tvf_declaration : path_expression function_parameters
        this.reportRange(listener.NodeType.TVFName, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 282: // create_model_statement : 'CREATE' opt_or_replace opt_create_scope 'MODEL' opt_if_not_exists path_expression opt_input_output_clause opt_transform_clause opt_remote_with_connection_clause opt_options_list opt_as_query_or_aliased_query_list
        this.reportRange(listener.NodeType.ModelName, 0, stack.slice(stack.length - 6, stack.length - 5));
        break;
      case 392: // create_view_statement : 'CREATE' opt_or_replace opt_create_scope opt_recursive 'VIEW' opt_if_not_exists maybe_dashed_path_expression opt_column_with_options_list opt_sql_security_clause opt_options_list as_query
        this.reportRange(listener.NodeType.ViewName, 0, stack.slice(stack.length - 5, stack.length - 4));
        break;
      case 393: // create_view_statement : 'CREATE' opt_or_replace 'MATERIALIZED' opt_recursive 'VIEW' opt_if_not_exists maybe_dashed_path_expression opt_column_with_options_list opt_sql_security_clause opt_partition_by_clause_no_hint opt_cluster_by_clause_no_hint opt_options_list as_query
        this.reportRange(listener.NodeType.ViewName, 0, stack.slice(stack.length - 7, stack.length - 6));
        break;
      case 394: // as_query : 'AS' query
        this.reportRange(listener.NodeType.Query, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 411: // export_data_statement : 'EXPORT' 'DATA' opt_with_connection_clause opt_options_list 'AS' query
        this.reportRange(listener.NodeType.Query, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 427: // import_statement : 'IMPORT' import_type path_expression_or_string opt_as_or_into_alias opt_options_list
        this.reportRange(listener.NodeType.ImportPath, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 428: // module_statement : 'MODULE' path_expression opt_options_list
        this.reportRange(listener.NodeType.ModuleName, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 482: // parenthesized_query : '(' query ')'
        this.reportRange(listener.NodeType.Query, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 493: // query_without_pipe_operators : with_clause query_primary_or_set_operation opt_order_by_clause opt_limit_offset_clause
        this.reportRange(listener.NodeType.WithClause, 0, stack.slice(stack.length - 4, stack.length - 3));
        break;
      case 494: // query_without_pipe_operators : 'WITH' syntax_problem query_primary_or_set_operation opt_order_by_clause opt_limit_offset_clause
        this.reportRange(listener.NodeType.WithClause, 0, stack.slice(stack.length - 5, stack.length - 3));
        break;
      case 495: // query_without_pipe_operators : with_clause_with_trailing_comma select_or_from_keyword
        this.reportRange(listener.NodeType.SyntaxProblem, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 497: // query_without_pipe_operators : opt_with_clause from_clause
        this.reportRange(listener.NodeType.FromQuery, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 498: // query_without_pipe_operators : opt_with_clause from_clause bad_keyword_after_from_query
        this.reportRange(listener.NodeType.SyntaxProblem, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 499: // query_without_pipe_operators : opt_with_clause from_clause bad_keyword_after_from_query_allows_parens
        this.reportRange(listener.NodeType.SyntaxProblem, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 533: // pipe_as : 'AS' identifier
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 539: // pipe_drop : 'DROP' identifier_list opt_comma
        this.reportRange(listener.NodeType.IDList, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 543: // pipe_set : 'SET' pipe_set_item_list opt_comma
        this.reportRange(listener.NodeType.PipeSet, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 558: // pipe_selection_item_with_order : expression identifier opt_grouping_item_order
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 559: // pipe_selection_item_with_order : expression 'AS' identifier opt_grouping_item_order
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 3, stack.length - 1));
        break;
      case 565: // pipe_rename_item : identifier opt_as identifier
        this.reportRange(listener.NodeType.PipeRenameOldName, 0, stack.slice(stack.length - 3, stack.length - 2));
        this.reportRange(listener.NodeType.PipeRenameNewName, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 572: // pipe_aggregate : 'AGGREGATE' pipe_selection_item_list_with_order_or_empty opt_group_by_clause_with_opt_comma_andorder
        this.reportRange(listener.NodeType.Select, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 580: // pipe_extend_item : expression identifier
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 581: // pipe_extend_item : expression 'AS' identifier
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 586: // select_clause : 'SELECT' opt_hint opt_select_with opt_all_or_distinct opt_select_as_clause 'FROM'
        this.reportRange(listener.NodeType.SyntaxProblem, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 600: // select : 'SELECT' opt_hint opt_select_with opt_all_or_distinct opt_select_as_clause opt_from_clause opt_clauses_following_from
        this._listener(listener.NodeType.SyntaxProblem, 0, 
           stack[stack.length - 2].sym.offset, stack[stack.length - 2].sym.offset);
        break;
      case 604: // opt_select_as_clause : 'AS' path_expression
        this.reportRange(listener.NodeType.PathExpr, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 629: // star_replace_item : expression 'AS' identifier
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 633: // star_modifiers : star_except_list star_replace_list_prefix ')'
        this.reportRange(listener.NodeType.StarReplace, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 636: // select_column : expression 'AS' identifier
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 637: // select_column : expression identifier
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 638: // select_column : expression '.' '*'
        this.reportRange(listener.NodeType.Star, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 639: // select_column : expression '.' '*' star_modifiers
        this.reportRange(listener.NodeType.Star, 0, stack.slice(stack.length - 3, stack.length - 0));
        break;
      case 640: // select_column : '*'
        this.reportRange(listener.NodeType.Star, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 641: // select_column : '*' star_modifiers
        this.reportRange(listener.NodeType.Star, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 707: // opt_pivot_or_unpivot_clause_and_alias : 'AS' identifier pivot_clause opt_as_alias
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 4, stack.length - 2));
        this.reportRange(listener.NodeType.PivotClause, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 708: // opt_pivot_or_unpivot_clause_and_alias : 'AS' identifier unpivot_clause opt_as_alias
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 4, stack.length - 2));
        this.reportRange(listener.NodeType.UnpivotClause, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 709: // opt_pivot_or_unpivot_clause_and_alias : 'AS' identifier qualify_clause_nonreserved
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 3, stack.length - 1));
        break;
      case 710: // opt_pivot_or_unpivot_clause_and_alias : identifier pivot_clause opt_as_alias
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 3, stack.length - 2));
        this.reportRange(listener.NodeType.PivotClause, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 711: // opt_pivot_or_unpivot_clause_and_alias : identifier unpivot_clause opt_as_alias
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 3, stack.length - 2));
        this.reportRange(listener.NodeType.UnpivotClause, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 712: // opt_pivot_or_unpivot_clause_and_alias : identifier qualify_clause_nonreserved
        this.reportRange(listener.NodeType.Alias, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 720: // model_clause : 'MODEL' path_expression
        this.reportRange(listener.NodeType.ModelClause, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 721: // connection_clause : 'CONNECTION' path_expression_or_default
        this.reportRange(listener.NodeType.ConnectionClause, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 757: // graph_node_pattern : '(' opt_identifier opt_is_label_expression opt_where_clause ')'
        this.reportRange(listener.NodeType.GraphNodePattern, 0, stack.slice(stack.length - 4, stack.length - 1));
        break;
      case 758: // opt_is_label_expression : 'IS' label_expression
        this.reportRange(listener.NodeType.GraphLabelFilter, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 804: // from_clause : 'FROM' from_clause_contents ','
        this.reportRange(listener.NodeType.SyntaxProblem, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 821: // grouping_set : rollup_list ')'
        this.reportRange(listener.NodeType.Rollup, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 822: // grouping_set : cube_list ')'
        this.reportRange(listener.NodeType.Cube, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 829: // grouping_item : rollup_list ')'
        this.reportRange(listener.NodeType.Rollup, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 830: // grouping_item : cube_list ')'
        this.reportRange(listener.NodeType.Cube, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 831: // grouping_item : grouping_set_list ')'
        this.reportRange(listener.NodeType.GroupingSetList, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 884: // aliased_query : identifier parenthesized_query
        this._listener(listener.NodeType.SyntaxProblem, 0, 
           stack[stack.length - 1].sym.offset, stack[stack.length - 1].sym.offset);
        break;
      case 992: // expression : expression KW_OR expression %prec KW_OR
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 993: // expression : expression 'AND' expression %prec 'AND'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 994: // expression : 'NOT' expression %prec UNARY_NOT_PRECEDENCE
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 998: // expression : expression distinct_operator expression %prec 'DISTINCT'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 999: // expression : expression in_operator opt_hint unnest_expression %prec 'IN'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 1000: // expression : expression in_operator opt_hint parenthesized_in_rhs %prec 'IN'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 1002: // expression : expression is_operator 'UNKNOWN' %prec 'IS'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 1003: // expression : expression is_operator null_literal %prec 'IS'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1004: // expression : expression is_operator boolean_literal %prec 'IS'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1005: // expression : expression comparative_operator expression %prec '='
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1006: // expression : expression '|' expression
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1007: // expression : expression '^' expression
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1008: // expression : expression '&' expression
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1009: // expression : expression '||' expression
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1010: // expression : expression shift_operator expression %prec '<<'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1011: // expression : expression additive_operator expression %prec '+'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1012: // expression : expression multiplicative_operator expression %prec '*'
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1013: // expression : unary_operator expression %prec UNARY_PRECEDENCE
        this.reportRange(listener.NodeType.Op, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1116: // case_no_value_expression_prefix : 'CASE' 'WHEN' expression 'THEN' expression
        this.reportRange(listener.NodeType.WhenThenExpr, 0, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 1117: // case_no_value_expression_prefix : case_no_value_expression_prefix 'WHEN' expression 'THEN' expression
        this.reportRange(listener.NodeType.WhenThenExpr, 0, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 1118: // case_value_expression_prefix : 'CASE' expression 'WHEN' expression 'THEN' expression
        this.reportRange(listener.NodeType.WhenThenExpr, 0, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 1119: // case_value_expression_prefix : case_value_expression_prefix 'WHEN' expression 'THEN' expression
        this.reportRange(listener.NodeType.WhenThenExpr, 0, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 1123: // case_expression : case_expression_prefix 'ELSE' expression 'END'
        this.reportRange(listener.NodeType.ElseExpr, 0, stack.slice(stack.length - 3, stack.length - 1));
        break;
      case 1148: // function_call_expression_base : function_name_from_keyword '(' %prec PRIMARY_PRECEDENCE
        this.reportRange(listener.NodeType.PathExpr, 0, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1200: // struct_constructor_prefix_without_keyword : '(' expression ',' expression
        this.reportRange(listener.NodeType.StructConstructorArg, 0, stack.slice(stack.length - 3, stack.length - 2));
        this.reportRange(listener.NodeType.StructConstructorArg, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 1201: // struct_constructor_prefix_without_keyword : struct_constructor_prefix_without_keyword ',' expression
        this.reportRange(listener.NodeType.StructConstructorArg, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 1227: // system_variable_expression : '@@' path_expression %prec DOUBLE_AT_PRECEDENCE
        this.reportRange(listener.NodeType.PathExpr, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 1228: // system_variable_expression : '@@' reserved_keyword_rule
        this.reportRange(listener.NodeType.PathExpr, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 1547: // define_table_statement : 'DEFINE' 'TABLE' path_expression options_list
        this.reportRange(listener.NodeType.TableName, listener.NodeFlags.RetainText, stack.slice(stack.length - 2, stack.length - 1));
        break;
      case 1572: // insert_statement : insert_statement_prefix query opt_assert_rows_modified opt_returning_clause
        this.reportRange(listener.NodeType.Query, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 1625: // call_statement_with_args_prefix : 'CALL' path_expression '(' tvf_argument
        this.reportRange(listener.NodeType.CallName, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 1628: // call_statement : 'CALL' path_expression '(' ')'
        this.reportRange(listener.NodeType.CallName, 0, stack.slice(stack.length - 3, stack.length - 2));
        break;
      case 1670: // elseif_clauses : elseif_clauses 'ELSEIF' expression 'THEN' statement_list
        this.reportRange(listener.NodeType.ElseIfClause, 0, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 1676: // when_then_clauses : when_then_clauses 'WHEN' expression 'THEN' statement_list
        this.reportRange(listener.NodeType.WhenThenClause, 0, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 1830: // define_macro_statement : 'DEFINE' 'MACRO' macro_identifier setof_not_EOI_or_SEMICOLON_list
        this.reportRange(listener.NodeType.MacroName, 0, stack.slice(stack.length - 2, stack.length - 1));
        this.reportRange(listener.NodeType.MacroBody, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 2203: // run_script_statement : 'RUN' string_literal
        this.reportRange(listener.NodeType.ID, listener.NodeFlags.RetainText, stack.slice(stack.length - 1, stack.length - 0));
        this.reportRange(listener.NodeType.RunPath, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
      case 2204: // run_script_name : run_script_name_segment '::' run_script_name_segment run_script_name$1
        this.reportRange(listener.NodeType.ID, listener.NodeFlags.RetainText, stack.slice(stack.length - 4, stack.length - 0));
        break;
      case 2205: // run_script_name : run_script_name_segment run_script_name$1
        this.reportRange(listener.NodeType.ID, listener.NodeFlags.RetainText, stack.slice(stack.length - 2, stack.length - 0));
        break;
      case 2212: // run_parameter : identifier '=' string_literal
        this.reportRange(listener.NodeType.RunParamValue, 0, stack.slice(stack.length - 1, stack.length - 0));
        break;
    }
    let nt = ptables.tmRuleType[rule];
    if (nt !== 0) {
      this._listener(nt & 0xffff, nt >> 16, lhs.sym.offset, lhs.sym.endoffset)
    }
  }

  recoverFromError(stream: stream.TokenStream, stack: common.StackEntry[], endState: number) : (common.StackEntry[] | null) {
    let recoverSyms: number[] = [];
    let recoverPos: number[] = [];

    if (common.debugSyntax) {
      common.debugLog("broke at", ptables.symbolName(this._next.symbol));
    }
    for (let size = stack.length; size > 0; size--) {
      if (gotoState(stack[size - 1].state, errSymbol) === -1) {
        continue;
      }
      recoverPos.push(size);
    }
    if (recoverPos.length === 0) {
      return null;
    }

    for (let i = 0; i < ptables.afterErr.length; i++) {
      let v = ptables.afterErr[i];
      recoverSyms[v / 8] |= (1 << (v % 8));
    }

    let canRecover = (symbol: number) : boolean => {
      return (recoverSyms[symbol / 8] & (1 << (symbol % 8))) != 0;
    }
    if (this._next.symbol === ptables.noToken) {
      this._next = stream.next(stack, endState);
    }
    // By default, insert 'error' in front of the next token.
    let s = this._next.offset;
    let e = s;
    let pending = stream.pending();
    for (let i = 0; i < pending.length; i++) {
      let tok = pending[i];
      // Try to cover all nearby invalid tokens.
      if (tok.symbol === token.TokenType.INVALID_TOKEN) {
        if (s > tok.offset) {
          s = tok.offset;
        }
        e = tok.endoffset;
      }
    }
    while (true) {
      let endoffset = this.skipBrokenCode(stream, canRecover);
      if (endoffset > e) {
        e = endoffset;
      }

      let matchingPos: number = 0;
      if (common.debugSyntax) {
        common.debugLog("trying to recover on", ptables.symbolName(this._next.symbol));
      }

      for (let i = 0; i < recoverPos.length; i++) {
        let pos = recoverPos[i];
        let [unused, res] = reduceAll(stack.slice(0, pos), gotoState(stack[pos - 1].state, errSymbol), this._next.symbol, endState);
        if (res) {
          matchingPos = pos;
          break;
        }
      }
      if (matchingPos === 0) {
        if (this._next.symbol === ptables.eoiToken) {
          return null;
        }
        recoverSyms[this._next.symbol / 8] &= ~(1 << (this._next.symbol % 8));
        continue;
      }

      if (matchingPos < stack.length) {
        if (s === e) {
          // Avoid producing syntax problems covering trailing whitespace.
          e = stack[stack.length - 1].sym.endoffset;
        }
        s = stack[matchingPos].sym.offset;
      }
      if (s !== e) {
        // Try to cover all trailing invalid tokens.
        let pending = stream.pending();
        for (let i = 0; i < pending.length; i++) {
          let tok = pending[i];
          if (tok.symbol === token.TokenType.INVALID_TOKEN && tok.endoffset > e) {
            e = tok.endoffset;
          }
        }
      }
      if (common.debugSyntax) {
        for (let i = stack.length - 1; i >= matchingPos; i--) {
          common.debugLog("dropped from stack: ", ptables.symbolName(stack[i].sym.symbol));
        }
        common.debugLog("recovered");
      }
      stream.flush(new common.Symbol(errSymbol, s, e));

      stack.push({
        sym: new common.Symbol(errSymbol, s, e),
        state: gotoState(stack[matchingPos - 1].state, errSymbol),
        
      });
      return stack;
    }
  }

  skipBrokenCode(stream: stream.TokenStream, canRecover: (symbol: number) => boolean) : number {
    let e: number = 0;
    while (this._next.symbol != ptables.eoiToken && !canRecover(this._next.symbol)) {
      if (common.debugSyntax) {
        common.debugLog("skipped while recovering:", ptables.symbolName(this._next.symbol), "(", stream.text(this._next), ")");
      }
      stream.flush(this._next);
      e = this._next.endoffset;
      this._next = stream.next(null, -1);
    }
    return e;
  }

  reportRange(t: listener.NodeType, flags: listener.NodeFlags, rhs: common.StackEntry[]) : void {
    while (rhs.length > 1 && rhs[rhs.length - 1].sym.offset === rhs[rhs.length - 1].sym.endoffset) {
      rhs = rhs.slice(0, rhs.length - 1);
    }
    this._listener(t, flags, rhs[0].sym.offset, rhs[rhs.length - 1].sym.endoffset);
  }

};

