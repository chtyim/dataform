// generated by Textmapper; DO NOT EDIT

import { NodeType, NodeFlags, Listener } from '../listener'
import { Parser, SyntaxError, ErrorMsg, ErrorHandler } from '../parser'
import { Selector } from '../selector';
import { TokenStream } from '../stream';
import { Tree, Node } from './tree'

/**
* Parses the given content string as a SqlStatement into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromSqlStatement(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseSqlStatement(s);
  };
  return createTree(content, parseFunc, eh);
}

/**
* Parses the given content string as a Script into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromScript(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseScript(s);
  };
  return createTree(content, parseFunc, eh);
}

/**
* Parses the given content string as a NextStatement into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromNextStatement(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseNextStatement(s);
  };
  return createTree(content, parseFunc, eh);
}

/**
* Parses the given content string as a NextScriptStatement into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromNextScriptStatement(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseNextScriptStatement(s);
  };
  return createTree(content, parseFunc, eh);
}

/**
* Parses the given content string as a NextStatementKind into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromNextStatementKind(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseNextStatementKind(s);
  };
  return createTree(content, parseFunc, eh);
}

/**
* Parses the given content string as a Expression into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromExpression(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseExpression(s);
  };
  return createTree(content, parseFunc, eh);
}

/**
* Parses the given content string as a Type into an AST {@link Tree}.
*
* @param content the content to parse
* @param eh the {@link ErrorHandler} to handle parsing error
* @returns an object containing the AST {@link Tree} in the "tree" field;
* or the {@link Error} in the "err" field if parsing failed.
*/
export function createTreeFromType(content: string, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const parseFunc = (p: Parser, s: TokenStream) : { err? : SyntaxError } => {
    return p.parseType(s);
  };
  return createTree(content, parseFunc, eh);
}

function createTree(content: string, parseFunc: (p: Parser, s: TokenStream) => { err? : SyntaxError }, eh: ErrorHandler): { tree?: Tree, err?: Error } {
  const builder = new TreeBuilder(content);
  const eventListener: Listener = (t: NodeType, flags: NodeFlags, offset: number, endOffset: number) => {
    builder.addNode(t, flags, offset, endOffset);
  };
  const ts = new TokenStream(content, eventListener);
  const p = new Parser(eh, eventListener);

  let res = parseFunc(p, ts);
  if (res.err) {
    return { err: new Error(ErrorMsg(res.err)) };
  }

  return builder.build();
}

class TreeBuilder {

  readonly _tree: DefaultTree;
  _stack: DefaultNode[];

  constructor(content: string) {
    this._tree = new DefaultTree(content);
    this._stack = [];
  }

  addNode(t: NodeType, flags: NodeFlags, offset: number, endOffset: number) {
    let start = this._stack.length;
    let end = start;

    while (start > 0 && this._stack[start - 1].offset() >= offset) {
      start--;
      if (this._stack[start].offset() >= endOffset) {
        end--;
      }
    }

    let node: DefaultNode = new DefaultNode(this._tree, t, offset, endOffset);
    if (start < end) {
      node._firstChild = this._stack[start];
      let prev: DefaultNode | null = null;
      for (let i = end - 1; i >= start; i--) {
        let n = this._stack[i];
        n._parent = node;
        n._next = prev;
        prev = n;
      }
    }
    if (end === this._stack.length) {
      this._stack = this._stack.slice(0, start);
      this._stack.push(node);
    } else if (start < end) {
      this._stack[start] = node;
      let copyLen = this._stack.length - end;
      this._stack.copyWithin(start + 1, end);
      this._stack = this._stack.slice(0, start + 1 + copyLen);
    } else {
      // push a node to the end to enlarge the array, which get replaced by the copyWithin call.
      this._stack.push(node);
      this._stack.copyWithin(start + 1, start);
      this._stack[start] = node;
    }
  }

  build(): { tree?: Tree, err?: Error } {
    this.addNode(NodeType.File, 0, 0, this._tree._content.length);
    this._tree._root = this._stack[0];
    return { tree: this._tree };
  }
}

class DefaultTree implements Tree {

  readonly _content: string;
  readonly _lines: number[];
  _root: Node;

  constructor(content: string) {
    this._content = content;
    this._lines = this.lineOffsets(content);
  }

  text(): string {
    return this._content;
  }

  root(): Node {
    return this._root;
  }

  // returns the start position of the node as 1-based line and column.
  lineColumn(offset: number): { line: number; column: number } {
    const lines = this._lines;

    // Use a binary search to find the line number.
    let left = 0;
    let right = lines.length - 1;
    let line = 0
    while (left <= right) {
      let mid = Math.floor((left + right) / 2)
      if (lines[mid] > offset) {
        right = mid - 1
      } else {
        line = mid
        left = mid + 1
      }
    }
    return { line: line + 1, column: offset - lines[line] + 1 };
  }

  private lineOffsets(str: string): number[] {
    const lines: number[] = [0]; // Initialize with the starting offset (0)
    let offset = 0;

    let i = str.indexOf('\n', offset);
    while (i !== -1) {
      lines.push(offset);
      offset = i + 1;
      i = str.indexOf('\n', offset);
    }

    return lines;
  }
}

class DefaultNode implements Node {
  _tree: DefaultTree;
  _type: NodeType;
  _offset: number;
  _endOffset: number;
  _parent: DefaultNode | null;
  _next: DefaultNode | null;
  _firstChild: DefaultNode | null;

  constructor(tree: DefaultTree, type: NodeType, offset: number, endOffset: number) {
    this._tree = tree;
    this._type = type;
    this._offset = offset;
    this._endOffset = endOffset;
    this._parent = null;
    this._next = null;
    this._firstChild = null;
  }

  type(): NodeType {
    return this._type;
  }

  offset(): number {
    return this._offset;
  }

  endOffset(): number {
    return this._endOffset;
  }

  tree(): Tree {
    return this._tree;
  }

  text(): string {
    return this._tree.text().substring(this._offset, this._endOffset);
  }

  lineColumn(): { line: number; column: number } {
    return this._tree.lineColumn(this._offset);
  }

  next(selector: Selector): Node | null {
    let n = this._next;
    while (n != null && !selector(n._type)) {
      n = n._next;
    }
    return n;
  }

  nextAll(selector: Selector): Node[] {
    let res: Node[] = [];
    let n = this._next;
    while (n != null) {
      if (selector(n._type)) {
        res.push(n);
      }
      n = n._next;
    }
    return res;
  }

  child(selector: Selector): Node | null {
    let c = this._firstChild;
    while (c != null && !selector(c._type)) {
      c = c._next;
    }
    return c;
  }

  children(selector: Selector): Node[] {
    let res: Node[] = [];
    let c = this._firstChild;
    while (c != null) {
      if (selector(c._type)) {
        res.push(c);
      }
      c = c._next;
    }
    return res;
  }
}